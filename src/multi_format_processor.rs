use anyhow::{anyhow, Result};\nuse ebur128::EbuR128;\nuse std::path::Path;\nuse symphonia::core::audio::{AudioBufferRef, Signal};\nuse symphonia::core::codecs::DecoderOptions;\nuse symphonia::core::formats::FormatOptions;\nuse symphonia::core::io::MediaSourceStream;\nuse symphonia::core::meta::MetadataOptions;\nuse symphonia::core::probe::Hint;\nuse tracing::{debug, warn};\n\n/// Audio format detection and conversion\npub struct MultiFormatProcessor;\n\nimpl MultiFormatProcessor {\n    /// Get peak level from any supported audio format\n    pub fn get_peak_level(input: &Path) -> Result<f64> {\n        let audio_data = Self::decode_audio_to_f32(input)?;\n        let mut peak: f32 = 0.0;\n        \n        for sample in &audio_data.samples {\n            let abs_sample = sample.abs();\n            if abs_sample > peak {\n                peak = abs_sample;\n            }\n        }\n        \n        if peak <= 0.0 {\n            return Ok(f64::NEG_INFINITY);\n        }\n        Ok(20.0 * (peak as f64).log10())\n    }\n    \n    /// Get LUFS level from any supported audio format\n    pub fn get_lufs_level(input: &Path) -> Result<f64> {\n        let audio_data = Self::decode_audio_to_f32(input)?;\n        \n        let mut meter = EbuR128::new(\n            audio_data.channels as u32,\n            audio_data.sample_rate as u32,\n            ebur128::Mode::I,\n        )?;\n        \n        meter.add_frames_f32(&audio_data.samples)?;\n        let lufs = meter.loudness_global()?;\n        Ok(lufs as f64)\n    }\n    \n    /// Decode any supported audio format to f32 samples\n    pub fn decode_audio_to_f32(input: &Path) -> Result<AudioData> {\n        // First try WAV with hound (faster for WAV files)\n        if let Some(ext) = input.extension() {\n            if ext.to_string_lossy().to_lowercase() == \"wav\" {\n                return Self::decode_wav_with_hound(input);\n            }\n        }\n        \n        // Use Symphonia for other formats\n        Self::decode_with_symphonia(input)\n    }\n    \n    /// Decode WAV files using hound (faster)\n    fn decode_wav_with_hound(input: &Path) -> Result<AudioData> {\n        let mut reader = hound::WavReader::open(input)\n            .map_err(|e| anyhow!(\"Failed to open WAV file: {}\", e))?;\n        \n        let spec = reader.spec();\n        let mut samples = Vec::new();\n        \n        match spec.sample_format {\n            hound::SampleFormat::Float => {\n                for sample in reader.samples::<f32>() {\n                    samples.push(sample?);\n                }\n            }\n            hound::SampleFormat::Int => {\n                let max = (1i64 << (spec.bits_per_sample - 1)) as f32;\n                for sample in reader.samples::<i32>() {\n                    samples.push(sample? as f32 / max);\n                }\n            }\n        }\n        \n        Ok(AudioData {\n            samples,\n            channels: spec.channels as usize,\n            sample_rate: spec.sample_rate as usize,\n        })\n    }\n    \n    /// Decode using Symphonia (supports MP3, FLAC, OGG, etc.)\n    fn decode_with_symphonia(input: &Path) -> Result<AudioData> {\n        let file = std::fs::File::open(input)?;\n        let mss = MediaSourceStream::new(Box::new(file), Default::default());\n        \n        let mut hint = Hint::new();\n        if let Some(extension) = input.extension() {\n            hint.with_extension(&extension.to_string_lossy());\n        }\n        \n        let meta_opts: MetadataOptions = Default::default();\n        let fmt_opts: FormatOptions = Default::default();\n        \n        let probed = symphonia::default::get_probe()\n            .format(&hint, mss, &fmt_opts, &meta_opts)\n            .map_err(|e| anyhow!(\"Failed to probe format: {}\", e))?;\n        \n        let mut format = probed.format;\n        let track = format\n            .tracks()\n            .iter()\n            .find(|t| t.codec_params.codec != symphonia::core::codecs::CODEC_TYPE_NULL)\n            .ok_or_else(|| anyhow!(\"No supported audio tracks found\"))?;\n        \n        let track_id = track.id;\n        let dec_opts: DecoderOptions = Default::default();\n        \n        let mut decoder = symphonia::default::get_codecs()\n            .make(&track.codec_params, &dec_opts)\n            .map_err(|e| anyhow!(\"Failed to create decoder: {}\", e))?;\n        \n        let mut samples = Vec::new();\n        let mut sample_rate = 0;\n        let mut channels = 0;\n        \n        // Decode all packets\n        loop {\n            let packet = match format.next_packet() {\n                Ok(packet) => packet,\n                Err(_) => break,\n            };\n            \n            if packet.track_id() != track_id {\n                continue;\n            }\n            \n            match decoder.decode(&packet) {\n                Ok(decoded) => {\n                    if sample_rate == 0 {\n                        if let Some(spec) = decoded.spec() {\n                            sample_rate = spec.rate as usize;\n                            channels = spec.channels.count();\n                        }\n                    }\n                    \n                    // Convert to f32\n                    match decoded {\n                        AudioBufferRef::F32(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                samples.extend_from_slice(channel_data);\n                            }\n                        }\n                        AudioBufferRef::U8(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push((sample as f32 - 128.0) / 127.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::U16(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push((sample as f32 - 32768.0) / 32767.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::U24(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push((sample as f32 - 8388608.0) / 8388607.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::U32(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push((sample as f32 - 2147483648.0) / 2147483647.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::S8(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push(sample as f32 / 127.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::S16(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push(sample as f32 / 32767.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::S24(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push(sample as f32 / 8388607.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::S32(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push(sample as f32 / 2147483647.0);\n                                }\n                            }\n                        }\n                        AudioBufferRef::F64(buf) => {\n                            for ch in 0..buf.spec().channels.count() {\n                                let channel_data = buf.chan(ch);\n                                for &sample in channel_data {\n                                    samples.push(sample as f32);\n                                }\n                            }\n                        }\n                    }\n                }\n                Err(symphonia::core::errors::Error::IoError(_)) => {\n                    // End of stream\n                    break;\n                }\n                Err(symphonia::core::errors::Error::DecodeError(_)) => {\n                    // Decode error, try to continue\n                    warn!(\"Decode error, skipping packet\");\n                    continue;\n                }\n                Err(e) => {\n                    return Err(anyhow!(\"Decode error: {}\", e));\n                }\n            }\n        }\n        \n        if samples.is_empty() {\n            return Err(anyhow!(\"No audio data decoded\"));\n        }\n        \n        Ok(AudioData {\n            samples,\n            channels,\n            sample_rate,\n        })\n    }\n    \n    /// Write audio data to WAV format (for compatibility with existing code)\n    pub fn write_wav_from_audio_data(\n        output: &Path,\n        audio_data: &AudioData,\n        bit_depth: u16,\n    ) -> Result<()> {\n        let spec = hound::WavSpec {\n            channels: audio_data.channels as u16,\n            sample_rate: audio_data.sample_rate as u32,\n            bits_per_sample: bit_depth,\n            sample_format: if bit_depth == 32 {\n                hound::SampleFormat::Float\n            } else {\n                hound::SampleFormat::Int\n            },\n        };\n        \n        crate::audio_processor::write_wav(output, &spec, &audio_data.samples)\n    }\n}\n\n/// Audio data structure\n#[derive(Debug, Clone)]\npub struct AudioData {\n    pub samples: Vec<f32>,\n    pub channels: usize,\n    pub sample_rate: usize,\n}\n\nimpl AudioData {\n    /// Get duration in seconds\n    pub fn duration_seconds(&self) -> f64 {\n        self.samples.len() as f64 / (self.channels * self.sample_rate) as f64\n    }\n}\n
